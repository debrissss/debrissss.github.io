{"meta":{"title":"LYM的学习空间","subtitle":"","description":"算法和数据结构","author":"LYM","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2021-11-09T01:43:40.957Z","updated":"2021-11-09T01:43:40.957Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-11-09T12:57:17.977Z","updated":"2021-11-09T12:57:17.977Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"Hi，欢迎来到我的学习空间。留言/催更: &#x74;&#101;&#x6e;&#99;&#98;&#x6e;&#122;&#x6f;&#x63;&#103;&#x6d;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;"}],"posts":[{"title":"单链表","slug":"数据结构/单链表","date":"2021-11-14T07:16:35.000Z","updated":"2021-11-15T14:05:12.963Z","comments":true,"path":"2021/11/14/数据结构/单链表/","link":"","permalink":"http://example.com/2021/11/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%8D%95%E9%93%BE%E8%A1%A8/","excerpt":"","text":"单链表的基本操作前言本篇文章将围绕单链表展开介绍，首先展示单链表各种操作的代码实现，然后介绍单链表相关的一些算法。 头文件和一些定义12345678910#include&lt;iostream&gt;using namespace std;#define TRUE 1#define FALSE 0#define OK 1#define ERROR 0#define INFEASIBLE -1#define OVERFLOW -2#define ElemType int#define Status int 定义单链表结构体12345typedef struct LinkNode//定义链表结点的结构体类型&#123; ElemType data;//结点的数据域 LinkNode* next;//结点的指针域&#125;*LinkList; 基本操作初始化1234567Status InitList(LinkList&amp; L)//初始化链表&#123; L = (LinkList)malloc(sizeof(LinkNode)); if (!L) exit(OVERFLOW); L-&gt;next = NULL; return OK;&#125; 判空1234Status ListEmpty(LinkList L)//判断链表是否为空表&#123; return (L-&gt;next == NULL);&#125; 插入1234567891011121314151617Status ListInsert(LinkList&amp; L, int i, ElemType e)//在链表中第i个位置插入元素e&#123; LinkList p = L; int j = 0; while (j &lt; i - 1 &amp;&amp; p)//在第i个位置插入，则寻找第i-1个结点 &#123; ++j; p=p-&gt;next; &#125; if (!p || j &gt; i)//!p-&gt;next对应插入位置大于链表长度加1，j&gt;i对应插入位置&lt;=0 return ERROR; LinkList q=(LinkList)malloc(sizeof(LinkNode)); q-&gt;data = e; q-&gt;next = p-&gt;next; p-&gt;next = q; return OK;&#125; 删除123456789101112131415Status ListDelete(LinkList&amp; L, int i, ElemType&amp; e)//删除链表中第i个结点，并用e带回删除结点的元素值&#123; LinkList p = L; int j = 0; while (j &lt; i - 1 &amp;&amp; p-&gt;next)//删除第i个元素，则寻找第i-1个结点 &#123; ++j; p = p-&gt;next; &#125; if (!p-&gt;next || j &gt; i)//!p-&gt;next对应删除位置大于链表加1，j&gt;i对应插入位置&lt;=0 return ERROR; e = p-&gt;next-&gt;data; p-&gt;next = p-&gt;next-&gt;next; return OK;&#125; 清空1234567891011Status ClearList(LinkList&amp; L)//清空链表&#123; LinkList p; while (L-&gt;next) &#123; p = L-&gt;next; L-&gt;next = p-&gt;next; free(p); &#125; return OK;&#125; 销毁123456789101112Status DestroyList(LinkList&amp; L)//销毁链表&#123; LinkList p; &#123; p = L-&gt;next; L-&gt;next = p-&gt;next; free(p); &#125; free(L); L = NULL; return OK;&#125; 求长1234567891011int ListLength(LinkList L)//求链表长度，即链表中结点个数&#123; LinkList p = L; int count = 0; while (p-&gt;next) &#123; p = p-&gt;next; ++count; &#125; return count;&#125; 取值1234567891011121314Status GetElem(LinkList L, int i, ElemType&amp; e)//获取第i个结点的元素值，并由e带回&#123; LinkList p = L-&gt;next; int j = 1; while (j != i &amp;&amp; p) &#123; ++j; p = p-&gt;next; &#125; if (!p || j &gt; i) return ERROR; e = p-&gt;data; return OK;&#125; 定位123456789101112int LocalElem(LinkList L, ElemType e, bool compare(ElemType,ElemType))//获取元素e在链表中的位序&#123; LinkList p = L-&gt;next; int i=1; while (p) &#123; if(compare(p-&gt;data, e)) return i; p = p-&gt;next; ++i; &#125; return 0;&#125; 求前驱12345678910Status PriorElem(LinkList L, ElemType cur_e, ElemType&amp; pre_e)//求元素cur_e在链表中的前驱，由pre_e带回&#123; LinkList p = L-&gt;next; while (p-&gt;next &amp;&amp; cur_e != p-&gt;next-&gt;data) p = p-&gt;next; if (!p-&gt;next) return ERROR; pre_e = p-&gt;data; return OK;&#125; 求后继12345678910Status NextElem(LinkList L, ElemType cur_e, ElemType&amp; next_e)//求元素cur_e在链表中的后继，由nexe_e带回&#123; LinkList p = L-&gt;next; while (p-&gt;next &amp;&amp; cur_e != p -&gt;data) p = p-&gt;next; if (!p-&gt;next) return ERROR; next_e = p-&gt;next-&gt;data; return OK;&#125; 遍历12345678910111213Status ListTraverse(LinkList L, void vi(ElemType e))//遍历链表&#123; LinkList p = L-&gt;next; while (p) &#123; vi(p-&gt;data); if (!p-&gt;next) cout &lt;&lt; &quot; &quot;; p=p-&gt;next; &#125; cout &lt;&lt; endl; return OK;&#125; 辅助函数12345678bool compare(ElemType e1, ElemType e2)//比较函数&#123; return (e1 == e2);&#125;void vi(ElemType e)//cout函数&#123; cout &lt;&lt; e;&#125; 合并两个有序单链表12345678910111213141516171819202122232425LinkList Combine(LinkList L1,LinkList L2, void Link(LinkList,LinkList))&#123; LinkList L3; InitList(L3); LinkList p1=L1-&gt;next,p2=L2-&gt;next,p3=L3; while(p1&amp;&amp;p2) &#123; if(p1-&gt;data&lt;p2-&gt;data) Link(p1,p3); else Link(p2,p3); &#125; while(p1) Link(p1,p3); while(p2) Link(p2,p3); return L3;&#125;void Link(LinkList L1,LinkList L2)&#123; LinkList q=(LinkList)malloc(sizeof(LinkNode)); q-&gt;data = L1-&gt;data; q-&gt;next = L2-&gt;next; L2-&gt;next = q; L2 = q; L1=L1-&gt;next;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"-单链表","slug":"单链表","permalink":"http://example.com/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"}],"author":"LYM"},{"title":"致来访者","slug":"hello-world","date":"2021-11-08T09:03:18.951Z","updated":"2021-11-15T14:22:12.683Z","comments":true,"path":"2021/11/08/hello-world/","link":"","permalink":"http://example.com/2021/11/08/hello-world/","excerpt":"","text":"欢迎来到我的个人博客！！！ 博客的由来一方面希望把自己在求学阶段的学习过程与心得体会记录下来，另一方面我自己也从很多优秀的博客文章中获益匪浅，因此就萌生了建立个人博客的想法。 未来的构想初次拥有了自己的个人博客，心情是非常激动的，希望自己能坚持写下去。我的目标是本科期间打造一个较为完备的代码学习笔记，努力去产出有价值的内容。从目前来看，内容上将有很长一段时间集中在算法与数据结构方面，其他方面的知识还没有涉猎，留待日后慢慢开拓。 最后我也仍在学习的过程当中，所以内容上可能会有疏漏和错误，欢迎批评与指正。如果我的内容能够对来访者有所帮助，那么我将非常开心。在这里，一起努力，共勉。（本文为置顶文章,更多内容请向下滑动或在分类或时间线内查看） 1234567#include&lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;&quot;Hello World!&quot;; return 0;&#125;","categories":[],"tags":[]}],"categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"-单链表","slug":"单链表","permalink":"http://example.com/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"}]}